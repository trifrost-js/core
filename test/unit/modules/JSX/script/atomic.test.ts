import {describe, it, expect} from 'vitest';
import {ATOMIC_GLOBAL, ATOMIC_VM_BEFORE, ATOMIC_VM_AFTER} from '../../../../../lib/modules/JSX/script/atomic';

describe('Modules - JSX - script - atomic', () => {
    describe('ATOMIC_GLOBAL', () => {
        it('Should be minified correct', () => {
            expect(ATOMIC_GLOBAL).toBe([
                'if(!window.$tfhydra){',
                /* Util: Debounce */
                'if(!window.$tfdebounce){',
                'window.$tfdebounce=(fn,delay)=>{',
                'let t;',
                'return(...args)=>{',
                'clearTimeout(t);',
                't=setTimeout(()=>fn(...args),delay);',
                '};',
                '};',
                '}',
                /* Util: Equal */
                'if(!window.$tfequal){',
                'const equal=(a,b)=>{',
                'if(a===b)return!0;',
                'switch(typeof a){',
                'case "number":return Number.isNaN(a)&& Number.isNaN(b);',
                'case "object":{',
                'if(!a || !b)return!1;',
                'if(Array.isArray(a))return Array.isArray(b)&& a.length===b.length && a.every((v,i)=>equal(v,b[i]));',
                'const pa=Object.prototype.toString.call(a);',
                'const pb=Object.prototype.toString.call(b);',
                'if(pa !==pb)return!1;',
                'switch(pa){',
                'case "[object Date]":return a.valueOf()===b.valueOf();',
                'case "[object Object]":{',
                'const ka=Object.keys(a);',
                'const kb=Object.keys(b);',
                'if(ka.length !==kb.length)return!1;',
                'return ka.every(k=>equal(a[k],b[k]));',
                '}',
                'case "[object Error]":return a.name===b.name && a.message===b.message;',
                'case "[object RegExp]":return String(a)===String(b);',
                'default:return !1;',
                '}',
                '}',
                'default:return !1;',
                '}};',
                'window.$tfequal=equal;',
                '}',
                /* Util: Clone */
                'if(!window.$tfclone){',
                'window.$tfclone=v=>(v===undefined || v===null || typeof v !=="object")? v:structuredClone(v);',
                '}',
                /* Relay */
                'if(!window.$tfr){',
                'const topics=Object.create(null);',
                'Object.defineProperty(window,"$tfr",{',
                'value:Object.freeze({',
                'publish:(msg,data)=>{',
                'if(typeof msg !=="string" || !topics[msg])return;',
                'for(let i=0;i<topics[msg].length;i++)try{topics[msg][i].fn(data)}catch{}',
                '},',
                'subscribe:(vmid,msg,fn)=>{',
                'if(',
                'typeof vmid !=="string" || ',
                'typeof msg !=="string" || ',
                'typeof fn !=="function"',
                ')return;',
                'const subs=(topics[msg]??=[]);',
                'const idx=subs.findIndex(el=>el.id===vmid);',
                'if(idx>=0)subs[idx].fn=fn;',
                'else subs.push({id:vmid,fn});',
                '},',
                'unsubscribe:(vmid,msg)=>{',
                'if(typeof vmid !=="string")return;',
                'if(typeof msg==="string"){',
                'if(!(msg in topics))return;',
                'topics[msg]=topics[msg].filter(el=>el.id !==vmid);',
                '}else{',
                'for(const key of Object.keys(topics)){',
                'topics[key]=topics[key].filter(el=>el.id !==vmid);',
                '}',
                '}',
                '}',
                '}),',
                'writable:!1,',
                'configurable:!1',
                '});',
                '}',
                /* Observer */
                'if(!window.$tfo){',
                'const observer=new MutationObserver(e=>{',
                'for(let x of e){',
                'for(let nRemoved of x.removedNodes){',
                'if(nRemoved.$tfVM){',
                'if(typeof nRemoved.$unmount==="function")try{nRemoved.$unmount()}catch{}',
                'window.$tfr?.unsubscribe(nRemoved.$uid);',
                'window.$tfc?.delete(nRemoved.$uid);',
                '}',
                '}',
                '}',
                '});',
                'observer.observe(document.body,{childList:!0,subtree:!0});',
                'window.$tfo=observer;',
                '}',
                /* Store */
                'if(!window.$tfs){',
                'const store=Object.create(null);',
                'Object.defineProperty(window,"$tfs",{',
                'value:Object.freeze({',
                'get:key=>{',
                'if(typeof key !=="string" || !key)return undefined;',
                'return store[key]',
                '},',
                'set:(key,val)=>{',
                'if(typeof key !=="string" || !key)return;',
                'store[key]=val;',
                'window.$tfr.publish("$store:"+key,val);',
                '},',
                '}),',
                'writable:!1,',
                'configurable:!1',
                '});',
                '}',
                /* Clock */
                'if(!window.$tfc){',
                'const clocks=new Map();',
                'let tick_pending=false;',
                'const tick_vms=new Set();',
                'window.$tfc=clocks;',
                'window.$tfcr=uid=>{',
                'tick_vms.add(uid);',
                'if(!tick_pending){',
                'tick_pending=true;',
                'requestAnimationFrame(()=>{',
                'const uids=[...tick_vms.values()];',
                'tick_pending=false;',
                'tick_vms.clear();',
                'for(let i=0;i<uids.length;i++){',
                'try{',
                'const fn=clocks.get(uids[i]);',
                'if(fn)fn();',
                '}catch{}',
                '}',
                '});',
                '}',
                '};',
                '}',
                /* Data Reactor */
                'if(!window.$tfdr){',
                'window.$tfdr=(root,raw)=>{',
                'const store=structuredClone(raw);',
                'const subs=Object.create(null);',
                'const pending=new Set();',
                'const get=path=>path.split(".").reduce((o,k)=>o?.[k],store);',
                'const set=(path,val)=>{',
                'const k=path.split(".");',
                'let c=store;',
                'for(let i=0;i<k.length-1;i++)c=c[k[i]]??={};',
                'const last=k.at(-1);',
                'if(c[last]===val)return;',
                'c[last]=val;',
                '};',
                /* Data Reactor @notify */
                'const notify=path=>{',
                'let c="";',
                'const parts=path.split(".");',
                'for(let i=0;i<parts.length;i++){',
                'c=i===0 ? parts[0]:c+"."+parts[i];',
                'pending.add(c);',
                '}',
                'window.$tfcr(root.$uid);',
                '};',
                /* Data Reactor @tick */
                'const tick=()=>{',
                'if(!pending.size)return;',
                'for(const key of pending){',
                'const handlers=subs[key];',
                'if(!handlers)continue;',
                'const val=get(key);',
                'for(let i=0;i<handlers.length;i++){',
                'try{',
                'const fn=handlers[i];',
                'if(!window.$tfequal(fn._last,val)){fn(val);fn._last=window.$tfclone(val);}',
                '}catch{}',
                '}}',
                'pending.clear();',
                '};',
                /* Data Reactor @patch */
                'const patch=(obj,val)=>{',
                'const marks=new Set();',
                'if(typeof obj==="string"){',
                'set(obj,val);',
                'marks.add(obj);',
                '}else{',
                'const walk=(path,cursor)=>{',
                'for(const k in cursor){',
                'const full=path ? path+"."+k:k;',
                'const v=cursor[k];',
                'if(Object.prototype.toString.call(v)==="[object Object]")walk(full,v);',
                'else{',
                'set(full,v);',
                'marks.add(full);',
                '}',
                '}',
                '};',
                'walk("",obj);',
                '}',
                'for(const path of marks)notify(path);',
                '};',
                /* Data Reactor @getIV */
                'const getIV=(els,path)=>{',
                'if(!els.length)return undefined;',
                'const el=els[0];',
                'if(el.type==="checkbox"){',
                'if(els.length>1)return[...els].filter(e=>e.checked).map(e=>e.value);',
                'return !!el.checked;',
                '}',
                'if(el.type==="radio"){',
                'const c=[...els].find(e=>e.checked);',
                'return c ? c.value:get(path);',
                '}',
                'if(el.tagName==="SELECT" && el.multiple)return[...el.selectedOptions].map(o=>o.value);',
                'return el.value;',
                '};',
                /* Data Reactor @setIV */
                'const setIV=(els,val)=>{',
                'if(!els.length)return;',
                'const e=els[0];',
                'if(els.length>1 && e.type==="checkbox"){',
                'for(const el of els)el.checked=Array.isArray(val)&& val.includes(el.value);',
                '}',
                'else if(e.type==="checkbox")e.checked=!!val;',
                'else if(e.type==="radio")e.checked=e.value===val;',
                'else if(e.tagName==="SELECT" && e.multiple && Array.isArray(val)){',
                'for(const o of e.options)o.selected=val.includes(o.value);',
                '}else e.value=val ?? "";',
                '};',
                'window.$tfc.set(root.$uid,tick);',
                /* Data Reactor @proxy */
                'return new Proxy(store,{',
                'get(_,key){',
                'switch(key){',
                'case "$bind":return(path,selector)=>{',
                'const els=[...root.querySelectorAll(selector)];',
                'if(!els.length)return;',
                'const c=get(path);',
                'if(c===undefined){',
                'set(path,getIV(els,path));',
                'notify(path);',
                '}else{',
                'setIV(els,c);',
                '}',
                'const fn=()=>{',
                'set(path,getIV(els,path));',
                'notify(path);',
                '};',
                'for(const el of els){',
                'el.addEventListener("input",fn);',
                'if(',
                'el.type==="checkbox" || ',
                'el.type==="radio" || ',
                'el.tagName==="SELECT"',
                ')el.addEventListener("change",fn);',
                '}',
                '(subs[path]??=[]).push(v=>setIV(els,v));',
                '};',
                'case "$watch":return(path,fn,opts={})=>{',
                'if(typeof path !=="string" || typeof fn !=="function")return;',
                'const{immediate=false,debounce=0}=Object.prototype.toString.call(opts)==="[object Object]" ? opts:{};',
                'const handler=Number.isInteger(debounce)&& debounce>0',
                ' ? window.$tfdebounce(fn,debounce)',
                ':fn;',
                '(subs[path]??=[]).push(handler);',
                'fn._last=window.$tfclone(get(path));',
                'if(immediate)handler(fn._last);',
                '};',
                'case "$set":return patch;',
                'default:return store[key];',
                '}',
                '},',
                'set(_,key,val){',
                'if(window.$tfequal(store[key],val))return true;',
                'store[key]=val;',
                'notify(String(key));',
                'return true;',
                '}',
                '});',
                '};',
                '}',
                /* Name Shim */
                'if(!window.__name){',
                'window.__name=(fn,n)=>{',
                'try{Object.defineProperty(fn,"name",{value:n});}catch{}',
                'return fn;',
                '};}',
                'Object.defineProperty(window,"$tfhydra",{get:()=>!0,configurable:!1});',
                '}',
            ].join(''));
        });
    });

    describe('ATOMIC_VM_BEFORE', () => {
        it('Should be minified correct', () => {
            expect(ATOMIC_VM_BEFORE).toBe([
                'if(!n.$tfVM){',
                'const i=crypto.randomUUID?.()|| Math.random().toString(36).slice(2);',
                'Object.defineProperties(n,{',
                '$uid:{get:()=>i,configurable:!1},',
                '$subscribe:{value:(msg,fn)=>w.$tfr.subscribe(i,msg,fn),configurable:!1,writable:!1},',
                '$unsubscribe:{value:msg=>w.$tfr.unsubscribe(i,msg),configurable:!1,writable:!1},',
                '$publish:{value:(msg,data)=>w.$tfr.publish(msg,data),configurable:!1,writable:!1},',
                '$storeGet:{value:w.$tfs.get,configurable:!1,writable:!1},',
                '$storeSet:{value:w.$tfs.set,configurable:!1,writable:!1},',
                // eslint-disable-next-line max-len
                '$dispatch:{value:(type,options)=>n.dispatchEvent(new CustomEvent(type,{detail:options?.data,bubbles:(options?.mode ?? "up")==="up",cancelable:!0})),configurable:!1,writable:!1},',
                '$tfVM:{get:()=>!0,configurable:!1}',
                '});',
                '}',
            ].join(''));
        });
    });

    describe('ATOMIC_VM_AFTER', () => {
        it('Should be minified correct', () => {
            expect(ATOMIC_VM_AFTER).toBe([
                'if(typeof n.$mount==="function")try{n.$mount()}catch{}',
            ].join(''));
        });
    });
});
